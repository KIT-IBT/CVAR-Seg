% -------------------------------------------------------
%
%    getActiveSegmentsFromNLEOInShortWindow  - Finds active segments 
%       based on NLEO in very short windows without moving average
%
%    Ver. 0.9.0
%
%    Created:                 Tobias Oesterlein  (15.5.2013)
%    Based on work by:       Marc Aubreville    (03.7.2009)
%    Last modified:           Tobias Oesterlein  (3.9.2013)
%
%    Institute of Biomedical Engineering
%    Universitaet Karlsruhe (TH)
%
%    http://www.ibt.kit.edu
%
%    Copyright 2000-2013 - All rights reserved.
%
% ------------------------------------------------------
%
% [stepFuncFinal,segments] = getActiveSegmentsFromNLEOInShortWindow(nleosignal, sampleFrequency, [k])
% Function to finde active segments in the signal generated by the NLEO.
% This analysis is based on Nguyen, Schilling, Dössel "A new approach for 
% automated location of active segments in intracardiac electrograms"
% Since it is for use with very short segments only, there is no sliding
% window applied
%
% Input:
%        nleosignal: NLEO filtered signal for segmentation (N samples x Z channels)
%
%        sampleFrequency: sampling frequency
%
%        k:     k factor for weightin standeard deviation
%
% Output: 
%        stepFuncFinal: step function of length N being 1 active and 0 otherwise
%
%        segments: list of the first and last index of each all A segments (A x 2)
%
% Revision history:
%   
%

function [stepFuncFinal,segments] = getActiveSegmentsFromNLEOInShortWindow(nleosignal, sampleFrequency, k)
%getActiveSegmentsFromNLEO Finds active segments based on NLEO


%% initialize variables

% set factor k weighting the standard deviation in the calculation of thresholds
if nargin<3 || isempty(k)
    k = 0.1;
end

% length of signal
sigLength=size(nleosignal,1);

% compute refractory period for removal of inactive segments
minimumRefractoryPeriodInactiveSegments_ms=30/2;
minimumRefractoryPeriodInactiveSegments_samples=round(minimumRefractoryPeriodInactiveSegments_ms*sampleFrequency/1000);

% compute minimum time for removal of active segments
minimumLengthActiveSegments_ms=10/2;
minimumLengthActiveSegments_samples=round(minimumLengthActiveSegments_ms*sampleFrequency/1000);

% reserve memory
stepFuncFinal=zeros(size(nleosignal));
segments=cell(size(nleosignal,2),1);


%% compute activity as initial step function

% get threshold for each signal. DO expect constant values within window
threshold=k*std(nleosignal);

% generate stepfunction based on energy threshold
stepFuncBig = nleosignal > repmat(threshold,sigLength,1);


%% loop since code is already written for this

for nSig=1:size(stepFuncBig,2)
    
    stepFunc=stepFuncBig(:,nSig);


%% postprocess: Remove Inactive Segments shorter than refractory length

% merge all active segments if distance is lower than refractroy period
% get start and end sample of active segments
segmentstarts=find(diff(stepFunc)==1);
segmentends=find(diff(stepFunc)==-1);

if ~isempty(segmentstarts)&&~isempty(segmentends)
    % change order if sequence starts with active data
    if segmentends(1)<segmentstarts(1)
        segmentstarts=[1; segmentstarts];
    end
    
    % add new ending if there are more beginnings than endings
    if length(segmentstarts)>length(segmentends)
        segmentends=[segmentends; size(stepFunc,1)];
    end
    
    % get length of inactive segments:
    lengthInactiveSegments=segmentstarts(2:end)-segmentends(1:end-1);
    
    % mark all inactive Segments to be removed
    tooShortInactiveSegments=find(lengthInactiveSegments<minimumRefractoryPeriodInactiveSegments_samples);
    
    % manually set step function indices to 1 for removed inactive Segments
    for nRemove=1:length(tooShortInactiveSegments)
        stepFunc(segmentends(tooShortInactiveSegments(nRemove)):segmentstarts(tooShortInactiveSegments(nRemove)+1))=1;
    end
end


%% postprocess: Remove Active Segments shorter than minimum length

% get start and end sample of active segments
segmentstarts=find(diff(stepFunc)==1);
segmentends=find(diff(stepFunc)==-1);

if ~isempty(segmentstarts)&&~isempty(segmentends)
    % change order if sequence starts with active data
    if segmentends(1)<segmentstarts(1)
        segmentstarts=[1; segmentstarts];
    end
    
    % add new ending if there are more beginnings than endings
    if length(segmentstarts)>length(segmentends)
        segmentends=[segmentends; size(stepFunc,1)];
    end
    
    % get length of inactive segments:
    lengthActiveSegments=segmentends-segmentstarts;
    
    % mark all inactive Segments to be removed
    tooShortActiveSegments=find(lengthActiveSegments<minimumLengthActiveSegments_samples);
    
    % manually set step function indices to 1 for removed inactive Segments
    for nRemove=1:length(tooShortActiveSegments)
        stepFunc(segmentstarts(tooShortActiveSegments(nRemove)):segmentends(tooShortActiveSegments(nRemove)))=0;
    end
end


%% Finalize

stepFuncFinal(:,nSig)=stepFunc;

segments{nSig}=[segmentstarts segmentends];

%  figure
%  plot(nleosignal(:,nSig),'b')
%  hold on
%  plot(stepFunc,'r')
%  ylim([0 max(nleosignal(:,nSig))])


end



















